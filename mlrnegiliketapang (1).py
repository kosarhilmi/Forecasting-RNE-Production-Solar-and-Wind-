# -*- coding: utf-8 -*-
"""MLRNEGiliKetapang.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1PKrgeSnRNSWal9talMeHiiDsy6DTtQES

MENGAMBIL DATA PERKIRAAN CUACA SELAMA 7 HARI (PERIODE 27 SEPTEMBER-3 OKTOBER
"""

import requests
import pandas as pd
from IPython.display import display

# --- KONFIGURASI ---
# Koordinat Pulau Gili Ketapang
LAT = -7.80
LON = 113.24

# Tentukan rentang tanggal yang diinginkan
start_date = "2025-09-27"
end_date = "2025-10-10"

# Tentukan parameter yang ingin diambil
params = "temperature_2m,relativehumidity_2m,windspeed_10m,winddirection_10m,windgusts_10m,precipitation,surface_pressure,uv_index,direct_normal_irradiance,visibility,weathercode,cloudcover"

# URL API Open-Meteo
api_url = f"https://api.open-meteo.com/v1/forecast?latitude={LAT}&longitude={LON}&hourly={params}&start_date={start_date}&end_date={end_date}"

# --- PROSES PENGAMBILAN DATA ---
try:
    response = requests.get(api_url)
    response.raise_for_status()
    data = response.json()

    # Open-Meteo memberikan data dalam format yang berbeda, pandas bisa langsung membacanya
    df = pd.DataFrame(data['hourly'])

    # Ganti nama kolom agar lebih mudah dibaca
    df = df.rename(columns={
        'time': 'datetime',
        'temperature_2m': 'temp',
        'relativehumidity_2m': 'humidity',
        'windspeed_10m': 'windspeed',
        'winddirection_10m': 'winddir',
        'windgusts_10m': 'windgust',
        'precipitation': 'precip',
        'surface_pressure': 'sealevelpressure',
        'uv_index': 'uvindex',
        'direct_normal_irradiance': 'solarradiation',
         'visibility': 'visibility(m)',
        'weathercode': 'weathercode',
        'cloudcover' : 'cloudcover'
    })

    # Tampilkan DataFrame
    print("Prakiraan Cuaca per Jam dari Open-Meteo:")
    display(df)

except Exception as e:
    print(f"Terjadi error: {e}")

# --- FUNGSI-FUNGSI ---

def convert_weathercode_to_wmo(code):
    """Menerjemahkan weathercode numerik menjadi deskripsi teks standar WMO."""
    wmo_map = {
        0: "Clear sky",
        1: "Mainly clear",
        2: "Partly cloudy",
        3: "Overcast",
        45: "Fog",
        48: "Depositing rime fog",
        51: "Drizzle: Light intensity",
        53: "Drizzle: Moderate intensity",
        55: "Drizzle: Dense intensity",
        61: "Rain: Slight intensity",
        63: "Rain: Moderate intensity",
        65: "Rain: Heavy intensity",
        66: "Freezing Rain: Light intensity",
        67: "Freezing Rain: Heavy intensity",
        71: "Snow fall: Slight intensity",
        73: "Snow fall: Moderate intensity",
        75: "Snow fall: Heavy intensity",
        77: "Snow grains",
        80: "Rain showers: Slight",
        81: "Rain showers: Moderate",
        82: "Rain showers: Violent",
        85: "Snow showers: Slight",
        86: "Snow showers: Heavy",
        95: "Thunderstorm: Slight or moderate",
        96: "Thunderstorm with slight hail",
        99: "Thunderstorm with heavy hail"
    }
    # Mengembalikan deskripsi dari map, atau 'Unknown' jika kode tidak ada
    return wmo_map.get(code, "Unknown")

df['conditions'] = df['weathercode'].apply(convert_weathercode_to_wmo)
df['datetime'] = pd.to_datetime(df['datetime'])

df['datetime'] = df['datetime'] + pd.Timedelta(hours=7)
display(df)

# Simpan DataFrame ke file CSV
df.to_csv('prakiraan_cuaca.csv', index=False)

df1 = pd.read_csv('historis_cuaca_2025-07-14_sampai_2025-07-16.csv')
df2 = pd.read_csv('historis_cuaca_2025-07-17_sampai_2025-07-31.csv')
df3 = pd.read_csv('historis_cuaca_2025-08-01_sampai_2025-08-16.csv')
df4 = pd.read_csv('historis_cuaca_2025-08-17_sampai_2025-08-31.csv')
df5 = pd.read_csv('historis_cuaca_2025-09-01_sampai_2025-09-26.csv')

import requests
import pandas as pd

# --- KONFIGURASI ---
LAT = -7.80
LON = 113.24
start_date = "2025-07-14"
end_date = "2025-07-16"

# Parameter cuaca (sudah benar)
params = "temperature_2m,relativehumidity_2m,windspeed_10m,winddirection_10m,windgusts_10m,precipitation,surface_pressure,uv_index,direct_normal_irradiance,visibility,weathercode,cloudcover"

# --- BAGIAN YANG DIPERBAIKI ---
# Ubah endpoint dari /archive menjadi /forecast
api_url = f"https://api.open-meteo.com/v1/forecast?latitude={LAT}&longitude={LON}&start_date={start_date}&end_date={end_date}&hourly={params}"

# --- PROSES PENGAMBILAN DATA ---
try:
    response = requests.get(api_url)
    response.raise_for_status()
    data = response.json()

    df_2 = pd.DataFrame(data['hourly'])

    # Ganti nama kolom
    df_2 = df_2.rename(columns={
        'time': 'datetime',
        'temperature_2m': 'temp',
        'relativehumidity_2m': 'humidity',
        'windspeed_10m': 'windspeed',
        'winddirection_10m': 'winddir',
        'windgusts_10m': 'windgust',
        'precipitation': 'precip',
        'surface_pressure': 'sealevelpressure',
        'uv_index': 'uvindex',
        'direct_normal_irradiance': 'solarradiation',
         'visibility': 'visibility(m)',
        'weathercode': 'weathercode',
        'cloudcover' : 'cloudcover'
    })

    print(f"📜 Data Cuaca Historis dari {start_date} hingga {end_date}:")
    display(df_2)

except Exception as e:
    print(f"Terjadi error: {e}")

df_2['conditions'] = df_2['weathercode'].apply(convert_weathercode_to_wmo)
  display(df_2)

# Simpan DataFrame ke file CSV
nama_file = f"historis_cuaca_{start_date}_sampai_{end_date}.csv"
df_2.to_csv(nama_file, index=False)

df1 = pd.read_csv('historis_cuaca_2025-07-14_sampai_2025-07-16.csv')
df2 = pd.read_csv('historis_cuaca_2025-07-17_sampai_2025-07-31.csv')
df3 = pd.read_csv('historis_cuaca_2025-08-01_sampai_2025-08-16.csv')
df4 = pd.read_csv('historis_cuaca_2025-08-17_sampai_2025-08-31.csv')
df5 = pd.read_csv('historis_cuaca_2025-09-01_sampai_2025-09-26.csv')

# pd.concat menerima sebuah list dari DataFrame yang ingin digabungkan
df_gabungan = pd.concat([df1, df2, df3, df4, df5], ignore_index=True)
df_gabungan['datetime'] = pd.to_datetime(df_gabungan['datetime'])
df_gabungan = df_gabungan.sort_values(by='datetime')
display(df_gabungan)

nama_file_baru = 'historisdata_Juli-September.csv'
df_gabungan.to_csv(nama_file_baru, index=False)

"""1. Generate Perkiraan Energi Dihasilkan (Energy PV)"""

hist_df = pd.read_csv('historisdata_Juli-September.csv')

import pandas as pd
import numpy as np
from google.colab import files
import io

# Kapasitas terpasang Photovoltaic dalam kW
total_capacity_kw = 758
display(hist_df)

hist_df['datetime'] = pd.to_datetime(hist_df['datetime'])

hist_df['datetime'] = hist_df['datetime'] + pd.Timedelta(hours=7)

display(hist_df)

def get_weather_factor_from_conditions(conditions):
    """Menentukan faktor efisiensi berdasarkan deskripsi cuaca (teks)."""
    if not isinstance(conditions, str):
        return 1.0

    conditions = conditions.lower() # Ubah ke huruf kecil

    # Logika disesuaikan dengan kategori umum di data Anda
    if 'rain' in conditions or 'thunderstorm' in conditions:
        return 0.4  # Efisiensi 40%
    elif 'overcast' in conditions:
        return 0.6  # Efisiensi 60%
    elif 'partly cloudy' in conditions:
        return 0.8  # Efisiensi 80%
    elif 'clear' in conditions: # Mencakup 'clear sky' dan 'mainly clear'
        return 1.0  # Efisiensi 100%

    # Nilai default untuk kondisi lain
    return 1.0

    # Penerapan fungsi
hist_df['weather_factor'] = hist_df['conditions'].apply(get_weather_factor_from_conditions)

"""2. Penyusunan Data Energy Dummy"""

hist_df['waktu'] = hist_df['datetime']
datetime = 'waktu'
hist_df[datetime] = pd.to_datetime(hist_df[datetime])
# 1. Inisialisasi faktor soiling
soiling_factor = 1.0  # Mulai dengan efisiensi 100%
daily_degradation = 0.997 # Efisiensi turun 0.3% setiap hari tanpa hujan
soiling_factors_list = []

# 2. Iterasi per hari untuk simulasi debu menumpuk dan dibersihkan hujan
for day, group in hist_df.groupby(hist_df['waktu'].dt.date):
    # Cek apakah kemarin ada hujan lebat (sebagai event pembersihan)
    # Kita anggap hujan jika 'rain' ada di 'conditions' selama lebih dari 2 jam
    hours_with_rain = group['conditions'].str.contains('rain', case=False).sum()

    if hours_with_rain > 2:
        soiling_factor = 1.0 # Efisiensi direset menjadi 100%
    else:
        # Jika tidak ada hujan pembersih, efisiensi menurun
        soiling_factor *= daily_degradation

    #  faktor untuk setiap jam di hari itu
    soiling_factors_list.extend([soiling_factor] * len(group))
# 3. Buat kolom baru di DataFrame
hist_df['hidden_soiling_factor'] = soiling_factors_list


# Basis MWH dari radiasi
hist_df['solarradiation'] = hist_df['solarradiation'].clip(lower=0)
base_mwh = (hist_df['solarradiation'] / 1000) * (total_capacity_kw / 1000) * hist_df['weather_factor']
#  Penalti Suhu
# Ubah suhu dari Celsius ke Fahrenheit DULU
temp_celsius = hist_df['temp']
temp_fahrenheit = (temp_celsius * 9/5) + 32

# SEKARANG, terapkan formula penalti Anda
temp_penalty_factor = 1.0 - (np.maximum(0, temp_fahrenheit - 77) * 0.005)

# Gabungkan semua faktor efisiensi
total_efficiency_factor = temp_penalty_factor * hist_df['hidden_soiling_factor']
# Hitung MWH Potensial
potential_mwh = base_mwh * total_efficiency_factor
#  Grid Curtailment
curtailment_threshold = potential_mwh[potential_mwh > 0].quantile(0.95)
mwh_after_curtailment = potential_mwh.clip(upper=curtailment_threshold)
#  Gangguan Acak
downtime_factor = np.ones(len(hist_df))
downtime_indices = hist_df.sample(frac=0.015).index # Tingkatkan probabilitas downtime jadi 1.5%
downtime_factor[downtime_indices] = 0
# Hitung MWH final
mwh_sebelum_noise_akhir = mwh_after_curtailment * downtime_factor

#  "mood" / noise yang saling berhubungan
autocorrelated_noise = np.zeros(len(hist_df))
# 'rho' -> seberapa kuat "memori" dari noise sebelumnya (0 s/d 1)
rho = 0.8
# 'noise_strength' -> seberapa besar fluktuasi acaknya
noise_strength = (mwh_sebelum_noise_akhir.mean() * 0.05) # Noise sebesar 5% dari rata-rata output

for i in range(1, len(hist_df)):
    # Nilai noise saat ini = (sedikit dari nilai noise kemarin) + (sedikit noise acak baru)
    autocorrelated_noise[i] = rho * autocorrelated_noise[i-1] + np.random.normal(0, noise_strength)

#  noise   "mood"
hist_df['MWH_dihasilkan'] = mwh_sebelum_noise_akhir + autocorrelated_noise
#  tidak ada energi negatif
hist_df['MWH_dihasilkan'] = hist_df['MWH_dihasilkan'].clip(lower=0)

kolom_hasil = [
    'datetime', 'tahun',	'bulan',	'hari',	'jam','temp', 'humidity', 'cloudcover', 'precip',	'windgust',	'windspeed',	'winddir',	'sealevelpressure','visibility','solarradiation', 'uvindex','conditions', 'weather_factor', 'MWH_dihasilkan'
]
kolom_tampil = [kolom for kolom in kolom_hasil if kolom in hist_df.columns]
hasil_df = hist_df[kolom_tampil]

print(hasil_df.head())
nama_file_output = 'datawithPVenergy.csv'
hasil_df.to_csv(nama_file_output, index=False)

"""A. Solar Machine Learning Modelling"""

# Initial Imports
import requests
import json
import pandas as pd
from google.colab import files
import io

# Data manipulation
import pandas as pd
import numpy as np

# datetime
from datetime import datetime
from datetime import timedelta

# ML Libraries
from sklearn.preprocessing import LabelEncoder
from sklearn.preprocessing import StandardScaler
from sklearn import tree
from sklearn.model_selection import train_test_split
from sklearn.metrics import r2_score
from sklearn.metrics import confusion_matrix, accuracy_score, classification_report, balanced_accuracy_score
from sklearn.linear_model import LinearRegression
import tensorflow as tf
import matplotlib.pyplot as plt
from pickle import dump
from pickle import load

# don't show warnings
import warnings
warnings.filterwarnings('ignore')

solar_df = pd.read_csv('datawithPVenergy.csv')

solar_df.head()

"""1. Preprocessing"""

solar_df['datetime'] = pd.to_datetime(solar_df['datetime'])

solar_df['datetime'] = pd.to_datetime(solar_df['datetime'])
solar_df['tahun'] = solar_df['datetime'].dt.year
solar_df['bulan'] = solar_df['datetime'].dt.month
solar_df['hari'] = solar_df['datetime'].dt.day
solar_df['jam'] = solar_df['datetime'].dt.hour

display(solar_df[['datetime', 'tahun', 'bulan', 'hari', 'jam']].head())

solar_df.head()

# Hitung jumlah missing values di setiap kolom
missing_values = solar_df.isnull().sum()

print("--- Jumlah Missing Values per Kolom ---")
# Tampilkan hanya kolom yang memiliki missing values
print(missing_values[missing_values > 0])

"""2. Pemodelan RLB untuk Solar"""

# Define X and Ys
X = solar_df.drop(["MWH_dihasilkan", 'datetime','solarradiation','conditions','weather_factor','windgust','windspeed','winddir','sealevelpressure','tahun','hari'], axis=1)
y = solar_df["MWH_dihasilkan"].ravel()

# Train
regr = LinearRegression()
regr.fit(X,y)

# Test
y_pred = regr.predict(X)

# accuracy
accuracy = regr.score(X,y)
print('Accuracy:',accuracy*100,'%')

# Create dataframe
regression_results = pd.DataFrame()
regression_results['datetime'] = solar_df['datetime']
regression_results['tahun'] = solar_df['tahun']
regression_results['bulan'] = solar_df['bulan']
regression_results['hari'] = solar_df['hari']
regression_results['jam'] = solar_df['jam']
regression_results['test'] = y
regression_results['pred'] = y_pred
regression_results = regression_results.set_index(regression_results['datetime']).drop('datetime', axis=1)
regression_results

"""Output linear regression bisa negatif, sehingga akan direplace nilai negatif dengan 0"""

regression_results[regression_results < 0] = 0
regression_results

"""Visualisasi Pemodelan RLB"""

# Plot the test and predicted val
datetime = '2025-08-25'
day_df = regression_results[datetime:datetime]
day_df.reset_index(drop=True, inplace=True)
plt.figure(figsize=(12, 6))
plt.plot(day_df['jam'],day_df['test'], label = 'Actual')
plt.plot(day_df['jam'],day_df['pred'], label = 'Predicted')
plt.ylabel('MHW_dihasilkan')
plt.xlabel('Jam dalam sehari')
plt.xticks(day_df['jam'])
plt.title(f'Solar Panel MWH Output on {datetime}')
plt.legend()
plt.grid(True, linestyle='--', alpha=0.6)
plt.savefig("solar_linear_regression")
plt.show()

#COBA RIDGE REGRESSION
X = solar_df.drop(["MWH_dihasilkan", 'datetime','solarradiation','conditions','weather_factor','windgust','windspeed','winddir','sealevelpressure','tahun','hari'], axis=1)
y = solar_df["MWH_dihasilkan"].ravel()


split_date = '2025-09-01'
train_indices = solar_df['datetime'] < split_date
test_indices = solar_df['datetime'] >= split_date

X_train, X_test = X[train_indices], X[test_indices]
y_train, y_test = y[train_indices], y[test_indices]

# 3. LLatih model
regr_validated = LinearRegression()
regr_validated.fit(X_train, y_train)

# 4. Evaluasi performa
accuracy_train = regr_validated.score(X_train, y_train)
accuracy_test = regr_validated.score(X_test, y_test)

print("\n" + "="*50)
print(f"Akurasi pada Data Latih (3 minggu pertama): {accuracy_train * 100:.2f}%")
print(f"Akurasi pada Data Uji (1 minggu terakhir): {accuracy_test * 100:.2f}%")
print("="*50)

if abs(accuracy_train - accuracy_test) < 0.05: # Jika selisih < 5%
    print("HASIL VALID: Performa model konsisten. Model tidak overfitting.")
else:
    print("warning: Performa model turun drastis pada data baru. Model mungkin overfitting.")

    # 1. prediksi data uji
y_pred_test = regr_validated.predict(X_test)

# 2.  residual
residuals = y_test - y_pred_test

# 3.  Residual Plot
import matplotlib.pyplot as plt

plt.figure(figsize=(10, 6))
plt.scatter(y_pred_test, residuals, alpha=0.5)
plt.axhline(y=0, color='r', linestyle='--')
plt.xlabel("Nilai Prediksi (Predicted Values)")
plt.ylabel("Residual (Error)")
plt.title("Residual Plot pada Data Uji")
plt.grid(True)
plt.show()

"""3. Pemodelan Neural Network untuk Solar"""

# features set

X = solar_df.drop(["MWH_dihasilkan", 'datetime', 'solarradiation','conditions','weather_factor','windgust','windspeed','winddir','sealevelpressure','tahun','hari'], axis=1)
y = solar_df[["MWH_dihasilkan"]]

# Bagi data jd Latih (85%) dan Uji (15%)
X_train_full, X_test, y_train_full, y_test = train_test_split(
    X, y, test_size=0.15, shuffle=False # shuffle=False PENTING untuk time series
)

# Bagi  data latih lagi jd Latih (70%) dan Validasi (15%)
X_train, X_val, y_train, y_val = train_test_split(
    X_train_full, y_train_full, test_size=0.176, shuffle=False # 0.176 * 0.85 ≈ 0.15
)

# Scaling data
scaler = StandardScaler()
# Latih scaler  pada data training
X_train_scaled = scaler.fit_transform(X_train)
# Terapkan scaler yang sama
X_val_scaled = scaler.transform(X_val)
X_test_scaled = scaler.transform(X_test)

X

X_train_scaled

"""Training Model"""

# deep neural net
number_input_features = len(X_train.columns)
hidden_nodes_layer1 =  number_input_features*5
hidden_nodes_layer2 =  number_input_features*4
hidden_nodes_layer3 =  number_input_features*3

nn = tf.keras.models.Sequential()

# First hidden layer
nn.add(tf.keras.layers.Dense(units=hidden_nodes_layer1, input_dim=number_input_features, activation="relu"))

# Second hidden layer
nn.add(tf.keras.layers.Dense(units=hidden_nodes_layer2, activation="relu"))

# Third hidden layer
nn.add(tf.keras.layers.Dense(units=hidden_nodes_layer3, activation="linear"))

# Output layer
nn.add(tf.keras.layers.Dense(units=1, activation="relu"))

# Compile the Sequential model
nn.compile(loss='mse', optimizer='sgd', metrics=['mse','mae'])

#summary of the model
nn.summary()

# Train  model
fit_model = nn.fit(X_train_scaled, y_train, epochs=200)

# Predict values for test set

y_pred = nn.predict(X_test_scaled)
accuracy_test_nn = r2_score(y_test, y_pred)

print("\n" + "="*50)
print(f"Akurasi R-squared Neural Network pada Data Uji: {accuracy_test_nn * 100:.2f}%")
print("="*50)

test_index = y_test.index
test_df_correct = solar_df.loc[test_index].copy()

# 1. Ambil baris data asli yang termasuk dalam set Uji
test_df = solar_df[test_indices].copy()

nn_results = pd.DataFrame(index=test_df_correct.index)
nn_results['datetime'] = solar_df['datetime']
nn_results['jam'] = test_df_correct['jam']
nn_results['test'] = y_test
nn_results['pred'] = y_pred.flatten()

# 3. Set 'datetime' sebagai index agar bisa difilter berdasarkan tanggal
nn_results = nn_results.set_index('datetime')

print("DataFrame 'nn_results' berhasil dibuat:")
print(nn_results.head())

waktu = '2025-09-22'
try:
    day_df = nn_results.loc[waktu]

    if not day_df.empty:
        print(f"\nMembuat plot untuk tanggal: {waktu}...")

        plt.figure(figsize=(12, 6))
        plt.plot(day_df['jam'], day_df['test'], label = 'Actual', marker='o')
        plt.plot(day_df['jam'], day_df['pred'], label = 'Predicted', linestyle='--')

        plt.ylabel('MWH Dihasilkan')
        plt.xlabel('Jam')
        plt.xticks(day_df['jam'])
        plt.title(f'Prediksi Neural Network vs Aktual pada {waktu}')
        plt.legend()
        plt.grid(True, alpha=0.5)
        plt.savefig('solar_neural_network')
        plt.show()
    else:
        print(f"\nTidak ada data yang ditemukan untuk tanggal {waktu}.")

except KeyError:
    print(f"\nERROR: Tanggal {waktu} tidak ditemukan di dalam indeks data uji.")

import joblib # Impor library joblib
nn.save('model_prediksi_solar.keras')
joblib.dump(scaler, 'scaler.pkl')

"""Prediksi Energi Surya (KWH) Dihasilkan berdasrakan model NN"""

file_model = 'model_prediksi_solar.keras'
file_scaler = 'scaler.pkl'

prediksi = pd.read_csv('prakiraan_cuaca.csv')

prediksi['datetime'] = pd.to_datetime(prediksi['datetime'])

prediksi['datetime'] = pd.to_datetime(prediksi['datetime'])
prediksi['tahun'] = prediksi['datetime'].dt.year
prediksi['bulan'] = prediksi['datetime'].dt.month
prediksi['hari'] = prediksi['datetime'].dt.day
prediksi['jam'] = prediksi['datetime'].dt.hour

display(prediksi[['datetime', 'tahun', 'bulan', 'hari', 'jam']].head())

import pandas as pd
import joblib
from tensorflow.keras.models import load_model
import matplotlib.pyplot as plt
import numpy as np
from sklearn.metrics import r2_score, mean_absolute_error, mean_squared_error


try:
  model = load_model(file_model)
  scaler = joblib.load(file_scaler)
  datetime_prakiraan = pd.to_datetime(prediksi['datetime'])
  features = ['temp', 'humidity','cloudcover','precip','uvindex','bulan', 'jam']
  prediksi_1 = prediksi[features]
  prediksi_scaled = scaler.transform(prediksi_1)
  prediksi_energi = model.predict(prediksi_scaled).flatten()
  hasil_prediksi = pd.DataFrame({
        'Waktu_Prakiraan': datetime_prakiraan,
        'Prediksi_KWh_Dihasilkan': prediksi_energi
  })
  display(hasil_prediksi.head())
  tanggal_start = hasil_prediksi['Waktu_Prakiraan'].min()
    # Tambahkan durasi 24 jam untuk mendapatkan data 1 hari penuh
  tanggal_fin = tanggal_start + pd.Timedelta(hours=24)

  hasil_pred_1 = hasil_prediksi[
   (hasil_prediksi['Waktu_Prakiraan'] >= tanggal_start) &
   (hasil_prediksi['Waktu_Prakiraan'] < tanggal_fin)
    ]
  # Plot hasil prediksi
  plt.figure(figsize=(15, 7))
  plt.plot(hasil_pred_1['Waktu_Prakiraan'], hasil_pred_1['Prediksi_KWh_Dihasilkan'], marker='o', linestyle='-')
  plt.title('Prakiraan Energi KWh yang Dihasilkan', fontsize=16)
  plt.xlabel('Tanggal dan Jam', fontsize=12)
  plt.ylabel('Prediksi KWh', fontsize=12)
  plt.grid(True)
  plt.tight_layout()
  plt.savefig('hasil_prediksi_energi.png')
  print("\nGrafik prediksi berhasil disimpan sebagai 'hasil_prediksi_energi.png'")

except FileNotFoundError as e:
  print(f"❌ ERROR: File tidak ditemukan. Pastikan Anda sudah mengunggah file '{e.filename}' ke sesi Colab Anda.")
except Exception as e:
  print(f"Terjadi error: {e}")

r2 = r2_score(y_test, y_pred)
mae = mean_absolute_error(y_test, y_pred)
mse = mean_squared_error(y_test, y_pred)
rmse = np.sqrt(mse)

print("--- Hasil Evaluasi Model pada Data Uji ---")
print(f"R-squared (R²): {r2:.4f}")
print(f"Mean Absolute Error (MAE): {mae:.4f} KWh")
print(f"Root Mean Squared Error (RMSE): {rmse:.4f} KWh")
print("---------------------------------------------")

# 4. Buat visualisasi untuk membandingkan nilai aktual vs. prediksi
plt.figure(figsize=(10, 6))
plt.scatter(y_test, y_pred, alpha=0.5)
plt.plot([min(y_test), max(y_test)], [min(y_test), max(y_test)], 'r--') # Garis diagonal (prediksi sempurna)
plt.title('Nilai Aktual vs. Prediksi pada Data Uji')
plt.xlabel('Nilai Aktual (KWh)')
plt.ylabel('Nilai Prediksi (KWh)')
plt.grid(True)
plt.savefig('evaluasi_model.png')
plt.show()

"""Sekitar 88,78% variasi atau perubahan pada data energi yang dihasilkan (MWH_dihasilkan) dapat dijelaskan oleh fitur-fitur (cuaca) dalam model.

MAE : Jika energi aktual yang dihasilkan adalah 0.5 KWh, prediksi model  mungkin berada di antara 0.4625 KWh dan 0.5375 KWh. Ini adalah tingkat kesalahan yang relatif kecil, menunjukkan prediksi yang cukup akurat.

RMSE : meskipun sebagian besar prediksi  sangat dekat dengan nilai asli (seperti yang ditunjukkan MAE), sesekali model membuat kesalahan yang sedikit lebih besar. Namun, perbedaannya yang tidak terlalu jauh dari MAE menandakan tidak ada banyak kesalahan prediksi yang ekstrim.

B. PEMODELAN WIND ENERGY
"""

import pandas as pd
import numpy as np
from google.colab import files
import io


hist_df_2 = pd.read_csv('historisdata_Juli-September.csv')
hist_df_2['datetime'] = pd.to_datetime(hist_df_2['datetime'])

hist_df_2['datetime'] = hist_df_2['datetime'] + pd.Timedelta(hours=7)

def get_weather_factor_from_conditions(conditions):
    """Menentukan faktor efisiensi berdasarkan deskripsi cuaca (teks)."""
    if not isinstance(conditions, str): return 1.0
    conditions = conditions.lower()
    if 'rain' in conditions or 'thunderstorm' in conditions: return 0.4
    elif 'overcast' in conditions: return 0.6
    elif 'partly cloudy' in conditions: return 0.8
    elif 'clear' in conditions: return 1.0
    return 1.0

def calculate_wind_power(wind_speed, capacity_kw, cut_in, rated_speed, cut_out):
    """Menghitung output daya (kW) berdasarkan kurva daya turbin sederhana."""
    power_output = np.zeros_like(wind_speed)

    # Antara cut-in dan rated speed, daya sebanding dengan kecepatan pangkat 3
    in_range = (wind_speed >= cut_in) & (wind_speed < rated_speed)
    power_output[in_range] = capacity_kw * ((wind_speed[in_range] - cut_in) / (rated_speed - cut_in)) ** 3

    # Antara rated dan cut-out speed, daya konstan pada kapasitas maksimum
    rated_range = (wind_speed >= rated_speed) & (wind_speed < cut_out)
    power_output[rated_range] = capacity_kw

    # Di luar rentang ini, output adalah 0
    return power_output

# --- SIMULASI DATA & PARAMETER TURBIN --

# Parameter Turbin Angin
total_capacity_kw = 100.0   # 100 kW
hub_height = 35.0           # 35 meter
reference_height = 10.0     # Ketinggian pengukuran angin standar
wind_shear_exponent = 0.143 # Eksponen untuk daratan terbuka

# Parameter Kurva Daya (contoh umum untuk turbin kelas ini)
cut_in_speed = 3.0    # m/s
rated_wind_speed = 12.0 # m/s
cut_out_speed = 25.0  # m/s

# 1. Hitung Weather Factor dari 'conditions'
hist_df_2['weather_factor'] = hist_df_2['conditions'].apply(get_weather_factor_from_conditions)

# 2. Penyesuaian Kecepatan Angin ke Ketinggian Hub
wind_speed_at_10m = hist_df_2['windspeed'] * (1000/3600) # Asumsi windspeed di data adalah km/j, ubah ke m/s
adjusted_wind_speed = wind_speed_at_10m * (hub_height / reference_height) ** wind_shear_exponent
hist_df_2['adjusted_wind_speed_ms'] = adjusted_wind_speed

# 3. Hitung Basis Daya (kW) dari Kurva Daya Turbin
base_power_kw = calculate_wind_power(
    adjusted_wind_speed,
    total_capacity_kw,
    cut_in_speed,
    rated_wind_speed,
    cut_out_speed
)
hist_df_2['base_power_kw'] = base_power_kw

# 4. Hitung Faktor Efisiensi & Penalti
# a. Penalti Kepadatan Udara (Air Density Penalty)
# Udara lebih panas/tekanan lebih rendah -> kurang padat -> daya lebih kecil
temp_kelvin = hist_df_2['temp'] + 273.15
pressure_pa = hist_df_2['sealevelpressure'] * 100
R_specific = 287.058
air_density = pressure_pa / (R_specific * temp_kelvin)
# Normalisasi (anggap kepadatan standar ISA adalah 1.225 kg/m^3)
density_factor = air_density / 1.225
hist_df_2['density_factor'] = density_factor

# b. Penalti Turbulensi (Turbulence Penalty)
# Hembusan angin (gust) yang jauh lebih tinggi dari kecepatan rata-rata mengurangi efisiensi
turbulence_intensity = (hist_df_2['windgust'] - hist_df_2['windspeed']) / hist_df_2['windspeed']
turbulence_penalty = 1 - np.clip(turbulence_intensity, 0, 0.5) # Batasi penalti maks 50%
hist_df_2['turbulence_penalty'] = turbulence_penalty

# c. Penalti Cuaca Ekstrem (dari weather_factor yang sudah ada)
# Anggap saat badai (thunderstorm), turbin akan berhenti (pitching)
weather_penalty = np.where(hist_df_2['conditions'].str.contains('Thunderstorm'), 0, 1)
hist_df_2['weather_penalty'] = weather_penalty

# 5. Gabungkan semua faktor dan hitung MWH final
# Total efisiensi (tidak termasuk weather_factor umum)
total_efficiency = density_factor * turbulence_penalty * weather_penalty
potential_power_kw = hist_df_2['base_power_kw'] * total_efficiency

# Data per jam, jadi kWh = kW * 1h. MWh = kWh / 1000
mwh_final = potential_power_kw / 1000

# Pastikan tidak ada energi negatif
hist_df_2['MWH_angin_dihasilkan'] = mwh_final.clip(lower=0)

kolom_tampil = [
    'datetime', 'temp','cloudcover','windgust','windspeed','winddir','sealevelpressure', 'adjusted_wind_speed_ms', 'MWH_angin_dihasilkan'
]
print("--- Hasil Generate Dummy Variabel Energi Angin ---")
display(hist_df_2[kolom_tampil].head(10))

hasil_df_2 = hist_df_2[kolom_tampil]
hasil_df_2.to_csv('datawithWind.csv', index=False)

wind_df = pd.read_csv('datawithWind.csv')
wind_df['datetime'] = pd.to_datetime(wind_df['datetime'])
wind_df['tahun'] = wind_df['datetime'].dt.year
wind_df['bulan'] = wind_df['datetime'].dt.month
wind_df['hari'] = wind_df['datetime'].dt.day
wind_df['jam'] = wind_df['datetime'].dt.hour

display(wind_df[['datetime', 'tahun', 'bulan', 'hari', 'jam']].head())

display(wind_df)

"""Regresi Linear"""

# Define X and Ys
X_w = wind_df.drop(["MWH_angin_dihasilkan", 'datetime','tahun','hari'], axis=1)
y_w = wind_df["MWH_angin_dihasilkan"].ravel()

# Train
regresi = LinearRegression()
regresi.fit(X_w,y_w)

# Test
y_pred_w = regresi.predict(X_w)

# accuracy
accuracy_w = regresi.score(X_w,y_w)
print('Accuracy:',accuracy_w*100,'%')

regresihasil = pd.DataFrame()
regresihasil['datetime'] = wind_df['datetime']
regresihasil['tahun'] = wind_df['tahun']
regresihasil['bulan'] = wind_df['bulan']
regresihasil['hari'] = wind_df['hari']
regresihasil['jam'] = wind_df['jam']
regresihasil['test'] = y_w
regresihasil['pred'] = y_pred_w
regresihasil = regresihasil.set_index(regresihasil['datetime']).drop('datetime', axis=1)
regresihasil

regresihasil[regresihasil < 0] = 0
regresihasil

# Plot the test and predicted val
datetime = '2025-08-25'
day_df_w = regresihasil[datetime:datetime]
day_df_w.reset_index(drop=True, inplace=True)
plt.figure(figsize=(12, 6))
plt.plot(day_df['jam'],day_df['test'], label = 'Actual')
plt.plot(day_df['jam'],day_df['pred'], label = 'Predicted')
plt.ylabel('MHW_dihasilkan')
plt.xlabel('Jam dalam sehari')
plt.xticks(day_df['jam'])
plt.title(f'Wind energy MWH Output on {datetime}')
plt.legend()
plt.grid(True, linestyle='--', alpha=0.6)
plt.savefig("wind_linear_regression")
plt.show()

#COBA RIDGE REGRESSION
X_w = wind_df.drop(["MWH_angin_dihasilkan", 'datetime','tahun','hari'], axis=1)
y_w = wind_df["MWH_angin_dihasilkan"].ravel()

split_date = '2025-09-01'
train_indices = wind_df['datetime'] < split_date
test_indices = wind_df['datetime'] >= split_date

X_train_w, X_test_w = X_w[train_indices], X_w[test_indices]
y_train_w, y_test_w = y_w[train_indices], y_w[test_indices]

# 3. LLatih model
regr_val = LinearRegression()
regr_val.fit(X_train_w, y_train_w)

# 4. Evaluasi performa
accuracy_train_w = regr_val.score(X_train_w, y_train_w)
accuracy_test_w = regr_val.score(X_test_w, y_test_w)

print("\n" + "="*50)
print(f"Akurasi pada Data Latih (3 minggu pertama): {accuracy_train_w * 100:.2f}%")
print(f"Akurasi pada Data Uji (1 minggu terakhir): {accuracy_test_w * 100:.2f}%")
print("="*50)

if abs(accuracy_train_w - accuracy_test_w) < 0.05: # Jika selisih < 5%
    print("HASIL VALID: Performa model konsisten. Model tidak overfitting.")
else:
    print("warning: Performa model turun drastis pada data baru. Model mungkin overfitting.")

    # 1. prediksi data uji
y_pred_test_w = regr_val.predict(X_test_w)

# 2.  residual
residuals_w = y_test_w - y_pred_test_w

# 3.  Residual Plot
import matplotlib.pyplot as plt

plt.figure(figsize=(10, 6))
plt.scatter(y_pred_test_w, residuals_w, alpha=0.5)
plt.axhline(y=0, color='r', linestyle='--')
plt.xlabel("Nilai Prediksi (Predicted Values)")
plt.ylabel("Residual (Error)")
plt.title("Residual Plot pada Data Uji")
plt.grid(True)
plt.show()

# features set

X_nn = solar_df.drop(["MWH_dihasilkan", 'datetime', 'solarradiation','conditions','weather_factor','windgust','windspeed','winddir','sealevelpressure','tahun','hari'], axis=1)
y_nn = solar_df[["MWH_dihasilkan"]]

# Bagi data jd Latih (85%) dan Uji (15%)
X_train_full_nn, X_test_nn, y_train_full_nn, y_test_nn = train_test_split(
    X_nn, y_nn, test_size=0.15, shuffle=False # shuffle=False PENTING untuk time series
)

# Bagi  data latih lagi jd Latih (70%) dan Validasi (15%)
X_train_nn, X_val_nn, y_train_nn, y_val_nn = train_test_split(
    X_train_full_nn, y_train_full_nn, test_size=0.176, shuffle=False # 0.176 * 0.85 ≈ 0.15
)

# Scaling data
scal = StandardScaler()
# Latih scaler  pada data training
X_train_scaled_nn = scal.fit_transform(X_train_nn)
# Terapkan scaler yang sama
X_val_scaled_nn = scal.transform(X_val_nn)
X_test_scaled_nn = scal.transform(X_test_nn)

# deep neural net
number_in_features = len(X_train_nn.columns)
hidden_nod_layer1 =  number_in_features*5
hidden_nod_layer2 =  number_in_features*4
hidden_nod_layer3 =  number_in_features*3

nn_1 = tf.keras.models.Sequential()

# First hidden layer
nn_1.add(tf.keras.layers.Dense(units=hidden_nod_layer1, input_dim=number_in_features, activation="relu"))

# Second hidden layer
nn_1.add(tf.keras.layers.Dense(units=hidden_nod_layer2, activation="relu"))

# Third hidden layer
nn_1.add(tf.keras.layers.Dense(units=hidden_nod_layer3, activation="linear"))

# Output layer
nn_1.add(tf.keras.layers.Dense(units=1, activation="relu"))

# Compile the Sequential model
nn_1.compile(loss='mse', optimizer='sgd', metrics=['mse','mae'])

#summary of the model
nn_1.summary()

# Train  model
fit_model_nn = nn_1.fit(X_train_scaled_nn, y_train_nn, epochs=200)

# Predict values for test set

y_pred_2 = nn_1.predict(X_test_scaled_nn)
accuracy_test_2 = r2_score(y_test_nn, y_pred_2)

print("\n" + "="*50)
print(f"Akurasi R-squared Neural Network pada Data Uji: {accuracy_test_2 * 100:.2f}%")
print("="*50)

test_index_nn = y_test_nn.index
test_df_corr = wind_df.loc[test_index_nn].copy()

# 1. Ambil baris data asli yang termasuk dalam set Uji
test_df_nn = solar_df[test_indices].copy()

nn_results_2 = pd.DataFrame(index=test_df_corr.index)
nn_results_2['datetime'] = wind_df['datetime']
nn_results_2['jam'] = test_df_corr['jam']
nn_results_2['test'] = y_test_nn
nn_results_2['pred'] = y_pred_2.flatten()

# 3. Set 'datetime' sebagai index agar bisa difilter berdasarkan tanggal
nn_results_2 = nn_results_2.set_index('datetime')

print("DataFrame 'nn_results' berhasil dibuat:")
print(nn_results_2.head())

waktu = '2025-09-16'
try:
    day_df_nn = nn_results_2.loc[waktu]

    if not day_df_nn.empty:
        print(f"\nMembuat plot untuk tanggal: {waktu}...")

        plt.figure(figsize=(12, 6))
        plt.plot(day_df_nn['jam'], day_df_nn['test'], label = 'Actual', marker='o')
        plt.plot(day_df_nn['jam'], day_df_nn['pred'], label = 'Predicted', linestyle='--')

        plt.ylabel('MWH Dihasilkan')
        plt.xlabel('Jam')
        plt.xticks(day_df_nn['jam'])
        plt.title(f'Prediksi Neural Network vs Aktual pada {waktu}')
        plt.legend()
        plt.grid(True, alpha=0.5)
        plt.savefig('solar_neural_network')
        plt.show()
    else:
        print(f"\nTidak ada data yang ditemukan untuk tanggal {waktu}.")

except KeyError:
    print(f"\nERROR: Tanggal {waktu} tidak ditemukan di dalam indeks data uji.")

import joblib # Impor library joblib
nn_1.save('model_prediksi_wind.keras')
joblib.dump(scal, 'scal.pkl')

"""Prediksi energi wind 14 hari kedepan.."""

file_mod = 'model_prediksi_wind.keras'
file_scal = 'scal.pkl'
prediksi_1 = pd.read_csv('prakiraan_cuaca.csv')
prediksi_1['datetime'] = pd.to_datetime(prediksi_1['datetime'])
prediksi_1['datetime'] = pd.to_datetime(prediksi_1['datetime'])
prediksi_1['tahun'] = prediksi_1['datetime'].dt.year
prediksi_1['bulan'] = prediksi_1['datetime'].dt.month
prediksi_1['hari'] = prediksi_1['datetime'].dt.day
prediksi_1['jam'] = prediksi_1['datetime'].dt.hour

display(prediksi_1[['datetime', 'tahun', 'bulan', 'hari', 'jam']].head())
import pandas as pd
import joblib
from tensorflow.keras.models import load_model
import matplotlib.pyplot as plt
import numpy as np
from sklearn.metrics import r2_score, mean_absolute_error, mean_squared_error

try:
  mod = load_model(file_mod)
  scal = joblib.load(file_scal)
  datetime_perkiraan = pd.to_datetime(prediksi_1['datetime'])
  feature = ['temp', 'humidity','cloudcover','precip','uvindex','bulan', 'jam']
  prediksi_2 = prediksi_1[feature]
  prediksi_scal = scal.transform(prediksi_2)
  prediksi_en = mod.predict(prediksi_scal).flatten()
  hasil_pred = pd.DataFrame({
        'Waktu_Perkiraan': datetime_perkiraan,
        'Prediksi_KWh_Dihasilkan': prediksi_en
  })
  display(hasil_pred.head())

  tanggal_mulai = hasil_pred['Waktu_Perkiraan'].min()
    # Tambahkan durasi 24 jam untuk mendapatkan data 1 hari penuh
  tanggal_akhir = tanggal_mulai + pd.Timedelta(hours=24)

  hasil_pred_1_hari = hasil_pred[
   (hasil_pred['Waktu_Perkiraan'] >= tanggal_mulai) &
   (hasil_pred['Waktu_Perkiraan'] < tanggal_akhir)
    ]
  # Plot hasil prediksi
  plt.figure(figsize=(15, 7))
  plt.plot(hasil_pred_1_hari['Waktu_Perkiraan'], hasil_pred_1_hari['Prediksi_KWh_Dihasilkan'], marker='o', linestyle='-')
  plt.title('Prakiraan Energi Angin KWh yang Dihasilkan', fontsize=16)
  plt.xlabel('Tanggal dan Jam', fontsize=12)
  plt.ylabel('Prediksi KWh', fontsize=12)
  plt.grid(True)
  plt.tight_layout()
  plt.savefig('hasil_pred_energi_angin.png')
  print("\nGrafik prediksi berhasil disimpan sebagai 'hasil_prediksi_energi.png'")

except FileNotFoundError as e:
  print(f"❌ ERROR: File tidak ditemukan. Pastikan Anda sudah mengunggah file '{e.filename}' ke sesi Colab Anda.")
except Exception as e:
  print(f"Terjadi error: {e}")

# --- 1. Impor Library ---
!pip install -q xgboost

import pandas as pd
import numpy as np
from sklearn.model_selection import train_test_split
from sklearn.metrics import r2_score, mean_absolute_error
import xgboost as xgb # Impor XGBoost
from IPython.display import display

# --- 2. Pembuatan & Feature Engineering Data Dummy (Sama seperti sebelumnya) ---
print("--- 1. Membuat & Memproses Data Dummy ---")
num_days = 500
dates = pd.to_datetime(pd.date_range(start='2023-01-01', periods=num_days, freq='D'))
df = pd.DataFrame({'datetime': dates,
                   'feedstock_kg': np.random.uniform(800, 1200, num_days),
                   'digester_temp_c': np.random.uniform(35, 40, num_days),
                   'digester_ph': np.random.uniform(6.8, 7.2, num_days)})
# Tambahkan ini di bagian Feature Engineering (Langkah 2)

# Fitur Interaksi 1: Jarak suhu dari titik optimal
optimal_temp = 37.5
df['temp_deviation'] = (df['digester_temp_c'] - optimal_temp).abs()

# Fitur Interaksi 2: Gabungan feedstock dengan deviasi suhu
df['feedstock_x_temp_dev'] = df['feedstock_kg'] * df['temp_deviation']
# Membuat pola non-linear yang lebih kuat untuk dipelajari model
temp_effect = 1 + np.sin((df['digester_temp_c'] - 35) / 5 * 2 * np.pi) * 0.1
df['biogas_yield_m3'] = (df['feedstock_x_temp_dev'] * 0.5 * temp_effect) + np.random.normal(0, 30, num_days)
df['biogas_yield_m3'] = df['biogas_yield_m3'].clip(lower=50)

# Feature Engineering
df['yield_lag_1_day'] = df['biogas_yield_m3'].shift(1)
df['feedstock_kg_rolling_7d'] = df['feedstock_kg'].rolling(window=7).mean()
df['day_of_year'] = df['datetime'].dt.dayofyear
df['day_of_year_sin'] = np.sin(2 * np.pi * df['day_of_year'] / 365.25)
df['day_of_year_cos'] = np.cos(2 * np.pi * df['day_of_year'] / 365.25)
df = df.dropna()

# --- 3. Persiapan Model ---
print("\n--- 2. Mempersiapkan Data untuk Model XGBoost ---")
features = ['feedstock_kg', 'digester_temp_c', 'digester_ph', 'yield_lag_1_day',
            'feedstock_kg_rolling_7d', 'day_of_year_sin', 'day_of_year_cos']
target = 'biogas_yield_m3'
X = df[features]
y = df[target]
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

# --- 4. Pelatihan Model XGBoost ---
print("\n--- 3. Melatih Model XGBoost ---")
# Buat model XGBoost Regressor
xgboost_model = xgb.XGBRegressor(n_estimators=100, learning_rate=0.1, max_depth=5, random_state=42)
xgboost_model.fit(X_train, y_train)
print("Model XGBoost selesai dilatih.")

# --- 5. Evaluasi Model ---
print("\n--- 4. Mengevaluasi Performa Model XGBoost ---")
y_pred = xgboost_model.predict(X_test)
r2 = r2_score(y_test, y_pred)
mae = mean_absolute_error(y_test, y_pred)
print(f"Performa model BARU (R²): {r2:.4f}")
print(f"Mean Absolute Error (MAE): {mae:.4f} m³")